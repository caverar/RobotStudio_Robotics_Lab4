# Lab 5: Industrial Robotics. I/O Signals

This repository contains the modules in RAPID generated by RobotStudio. On one hand, you will find how through different input signals, we can control and select different routines to draw the letters AEC (our name initials) with the robot ABB IRB140 in an inclined and horizontal plane. On the other hand, you will find how with different input signals the robot can perform a routine of pick and place using a gripper and three different objects.

## Authors

- Maria Alejandra Arias Frontanilla
- Camilo Andres Vera Ruiz
- Edwin Alfredo Higuera Bustos

# Adding digital inputs to the lab 4

In the last [lab](https://github.com/ariasAleia/RobotStudio_Robotics_Lab4) we develop two rapid modules to execute two different paths to draw the letters "AEC" both on the floor and on an inclined plane, the results were satisfactory but there is a problem, this modules begin the trajectory execution immediately, after the program load, and it only executes a single trajectory a single time, but in a real industrial application this behavior will never be useful, a robot must automate some heavy or repetitive task so there is the necessity of execute a trajectory multiple times taking into account the state of the world around it, in other words executing some task at a given moment and at a given input state, such as buttons, sensors, controllers and so on.

In order to be able to do that, a rapid module with two buttons inputs is develop, the main idea is to execute any of the two last lab trajectories by the press of two buttons, each button to each trajectory.

The first step is to create some inputs, this can be achieved in RobotStudio by the option "Configuration - I/O System" as showed bellow. Two signal named DI_01 and DI_02 are created, the first one for the horizontal plane, and the second one for the inclined plane.

![im9](images/signals_punto1.png)

Then the RAPID code for the last lab is imported and some logic is added. Two work objects are defined, one for the horizontal plane and the other for the inclined plane. All the trajectories and targets were defined previously.

The logic is pretty simple, the main routine defined in `main()`, it executes an infinite loop that waits for a button using if statements, in the case of any of the buttons is pressed the full path is executed including homing both at beginning and ending of the movement. The code is showed bellow and the .mod file ready to use with the IRB140 robot can be found [here](Module1.mod)

```rapid
MODULE Module1
        PERS tooldata Marcador:=[TRUE,[[0,-0.174,150.662],[0.981957062,0.189104012,0,0]],[0.1,[0.001,0,66.262],[1,0,0,0],0,0,0]];
    TASK PERS wobjdata Tablero:=[FALSE,TRUE,"",[[424.865,295.588,71.2],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];
    CONST robtarget Target_Up:=[[140,125,150],[0,0,1,0],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_A1:=[[145,210,0],[0,0,1,0],[0,1,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_A2:=[[265,170,0],[0,0,1,0],[0,0,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_A3:=[[145,130,0],[0,0,1,0],[0,1,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_Home:=[[636.768770631,-0.174,604.169],[0.490978531,0.094552006,0.850399762,-0.163768878],[0,-1,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_E1:=[[145,30,0],[0,0,1,0],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_E2:=[[145,110,0],[0,0,1,0],[0,1,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_E3:=[[265,110,0],[0,0,1,0],[0,0,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_E4:=[[265,30,0],[0,0,1,0],[0,0,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_C1:=[[90,85,0],[0,0,1,0],[0,1,-2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_C2:=[[130,125,0],[0,0,1,0],[0,1,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_C3:=[[90,165,0],[0,0,1,0],[0,1,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_C4:=[[50,165,0],[0,0,1,0],[0,1,-2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_C5:=[[10,125,0],[0,0,1,0],[0,1,-2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_C6:=[[50,85,0],[0,0,1,0],[0,1,-2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_LineA:=[[205,190,0],[0,0,1,0],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_LineA_End:=[[205,150,0],[0,0,1,0],[0,0,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_LineE:=[[205,110,0],[0,0,1,0],[0,0,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Target_LineE_End:=[[205,40,0],[0,0,1,0],[0,0,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];

    PROC main()
        WHILE TRUE DO
            IF DI_01 = 1 THEN
                Tablero:=[FALSE,TRUE,"",[[424.865,295.588,71.2],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];
                Path_A;
                Path_E;
                Path_C;
                Path_Lines;
            ENDIF
            IF DI_02 = 1 THEN
                Tablero:=[FALSE,TRUE,"",[[186.9,-412.1,71.2],[0.683012702,-0.183012702,-0.183012702,-0.683012702]],[[0,0,0],[1,0,0,0]]];
                Path_A;
                Path_E;
                Path_C;
                Path_Lines;
            ENDIF
        ENDWHILE
        
    ENDPROC
    PROC Path_A()
        MoveJ Target_Home,v400,fine,Marcador\WObj:=wobj0;
        MoveJ Target_Up,v400,fine,Marcador\WObj:=Tablero;
        MoveJ Target_A1,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_A2,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_A3,v400,fine,Marcador\WObj:=Tablero;
        MoveJ Target_Up,v400,fine,Marcador\WObj:=Tablero;
    ENDPROC
    PROC Path_E()
        MoveL Target_E1,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_E2,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_E3,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_E4,v400,fine,Marcador\WObj:=Tablero;
        MoveJ Target_Up,v400,fine,Marcador\WObj:=Tablero;
    ENDPROC
    PROC Path_C()
        MoveL Target_C1,v400,fine,Marcador\WObj:=Tablero;
        MoveC Target_C2,Target_C3,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_C4,v400,fine,Marcador\WObj:=Tablero;
        MoveC Target_C5,Target_C6,v400,fine,Marcador\WObj:=Tablero;
        MoveJ Target_Up,v400,fine,Marcador\WObj:=Tablero;
    ENDPROC
    PROC Path_Lines()
        MoveL Target_LineA,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_LineA_End,v400,fine,Marcador\WObj:=Tablero;
        MoveJ Target_Up,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_LineE,v400,fine,Marcador\WObj:=Tablero;
        MoveL Target_LineE_End,v400,fine,Marcador\WObj:=Tablero;
        MoveJ Target_Up,v400,fine,Marcador\WObj:=Tablero;
        MoveJ Target_Home,v400,fine,Marcador\WObj:=wobj0;
    ENDPROC
ENDMODULE
```

RobotStudio allow us to synchronize the graphic environment with the RAPID code, so instead of generating the code in the same way as the last lab, we generate the environment configurations from the code, using the option `Synchronize with the station`, this allow us to verify the proper behavior of the code. The two images bellow show the synchronized environment, excuting each trayectory at the order of the inputs. This ones can be controlled by the right panel.

![im10](images/signal1_horizontal_plane.png)
![im11](images/signal2_inclined_plane.png)

The full simulation can bee seen [here](https://www.youtube.com/watch?v=tKo-fJIsRrs)

For the physical implementation a DSQC 652 module like the one in the image bellow, is needed to add I/O support to the controller, this module a comunication protocol called DeviceNet.

![iomod](images/IOM.png)

In addition to that a control box with some buttons is needed, fortunately the lab already has one properly connected to the  DSQC 652 module like the one in the image bellow.
![box](images/controlBox.png)

A simplified diagram of the full connection including the IRB140 is showed bellow for illustrative purposes.

![diag1](images/diag1.png)

Finally the physical implementation can be seen [here](https://www.youtube.com/watch?v=5Umj_LPHBDM)

# Pick and Place with pneumatic actuator and I/O


![im1](images/StationLogic.png)

![im2](images/physics_pallet.png)

![im3](images/signals.png)
![im4](images/IO_Signals.png)
![im5](images/robot.png)
![im6](images/path_examples.png)
![im7](images/synchronize.png)
![im8](images/restart.png)


![im9](images/fullneu.png)  

![im10](images/neu1.png)  

![diag2](images/diag2.png)

The full simulation can be found [here](https://www.youtube.com/watch?v=OrLED6QgCuY)
